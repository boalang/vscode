//
// Copyright 2022, Robert Dyer,
//                 and University of Nebraska Board of Regents
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import * as vscode from 'vscode';
import * as consts from '../consts';
import { getAnalysesRange } from '../utils';

export default class StudyConfigCodelensProvider implements vscode.CodeLensProvider {
    public provideCodeLenses(document: vscode.TextDocument, token: vscode.CancellationToken): vscode.CodeLens[] | Thenable<vscode.CodeLens[]> {
        const lenses = [];
        const docPath = document.uri.fsPath.substring(0, document.uri.fsPath.lastIndexOf('/'));

        // looks for the analysis section, e.g.: "analyses": {
        for (const output of document.getText().matchAll(/"analyses"\s*:\s*{/g)) {
            const range = new vscode.Range(document.positionAt(output.index), document.positionAt(output.index + 1));
            lenses.push(new vscode.CodeLens(range, {
                title: '$(run-all) Run All Analyses',
                tooltip: 'Runs all known analyses (make all)\nNote: this might trigger queries to run and/or download',
                command: 'boalang.template.make'
            }));

            lenses.push(new vscode.CodeLens(range, {
                title: '$(trash) Clean Analyses Outputs',
                tooltip: 'Cleans all tables and figures generated by any analysis (make clean)',
                command: 'boalang.template.clean'
            }));
        }

        // looks for the analysis section, e.g.: "queries": {
        for (const output of document.getText().matchAll(/"queries"\s*:\s*{/g)) {
            const range = new vscode.Range(document.positionAt(output.index), document.positionAt(output.index + 1));
            lenses.push(new vscode.CodeLens(range, {
                title: '$(graph) Generate All Data',
                tooltip: 'Runs queries, downloads outputs, and converts to CSV as necessary (make data)',
                command: 'boalang.template.generateData'
            }));

            lenses.push(new vscode.CodeLens(range, {
                title: '$(trash) Clean All Data',
                tooltip: 'Cleans all downloaded and generated output files (make clean-data)',
                command: 'boalang.template.cleanData'
            }));
        }

        // looks for query outputs, e.g.: "kotlin/rq1.txt": {
        for (const output of document.getText().matchAll(/"([^"]+\.txt)"\s*:\s*{/g)) {
            const range = new vscode.Range(document.positionAt(output.index + 1), document.positionAt(output.index + 1 + output[1].length));
            lenses.push(new vscode.CodeLens(range, {
                title: '$(cloud-download) Download Output',
                tooltip: `Make sure this output is up to date and downloaded (make ${consts.outputPath}/${output[1]})`,
                command: 'boalang.template.downloadOutput',
                arguments: [output[1]]
            }));

            lenses.push(new vscode.CodeLens(range, {
                title: '$(trash) Clean Output',
                tooltip: `Cleans downloaded and generated output files for ${consts.outputPath}/${output[1]} (make clean-${consts.outputPath}/${output[1]})`,
                command: 'boalang.template.cleanOutput',
                arguments: [output[1]]
            }));
        }

        // looks for CSV files, e.g.: "csv": "kotlin/dupes.csv"
        for (const csv of document.getText().matchAll(/"([^"]+\.csv)"/g)) {
            const range = new vscode.Range(document.positionAt(csv.index + 1), document.positionAt(csv.index + 1 + csv[1].length));
            lenses.push(new vscode.CodeLens(range, {
                title: '$(table) Generate CSV',
                tooltip: `Generates the CSV output (make ${consts.csvPath}/${csv[1]})\nNote: this might trigger a download on the input`,
                command: 'boalang.template.generateCSV',
                arguments: [csv[1]]
            }));
        }

        // looks for processor output files, e.g.: "output": "kotlin/dupes.txt",
        for (const output of document.getText().matchAll(/"output"\s*:\s*"([^"]+\.txt)"/g)) {
            const range = new vscode.Range(document.positionAt(output.index + 1), document.positionAt(output.index + 1 + output[1].length));
            lenses.push(new vscode.CodeLens(range, {
                title: '$(list-filter) Run Processor',
                tooltip: `Run the processor (make ${output[1]})\nNote: this might trigger a download on the input`,
                command: 'boalang.template.runProcessor',
                arguments: [output[1]]
            }));
        }

        // scope completions to the "analyses" key
        const { analysesStart, analysesEnd } = getAnalysesRange(document);

        // looks for analyses, e.g.: "rq1.py": {
        for (const target of document.getText().matchAll(/"([^"]+)\.py"\s*:/g)) {
            const startPos = target.index + 1;

            // scope completions to the "analyses" key
            if (startPos > analysesStart && startPos < analysesEnd) {
                const range = new vscode.Range(document.positionAt(startPos), document.positionAt(startPos + target[1].length));
                lenses.push(new vscode.CodeLens(range, {
                    title: '$(play) Run Analysis',
                    tooltip: `Run this analysis (make ${target[1]})\nNote: this will download all inputs`,
                    command: 'boalang.template.runAnalysis',
                    arguments: [target[1]]
                }));
            }
        }

        return lenses;
    }
}
